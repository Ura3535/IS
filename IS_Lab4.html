<!DOCTYPE html>
<html lang="uk">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Graph Coloring Visualizer (CSP, Backtracking)</title>
    <style>
      body {
        font-family: system-ui, -apple-system, "Segoe UI", Roboto,
          "Helvetica Neue", Arial;
        margin: 18px;
      }
      .controls {
        display: flex;
        gap: 12px;
        align-items: flex-start;
      }
      .left {
        display: flex;
        flex-direction: column;
        gap: 10px;
        width: 260px;
      }
      label {
        font-size: 14px;
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      textarea {
        font-family: monospace;
      }
      #canvasWrap {
        display: flex;
        gap: 16px;
        margin-top: 12px;
      }
      svg {
        background: #fff;
        border: 1px solid #ddd;
        border-radius: 8px;
      }
      button {
        padding: 8px 12px;
        border-radius: 6px;
        border: 1px solid #bbb;
        background: #f2f2f2;
        cursor: pointer;
      }
      button:active {
        transform: translateY(1px);
      }
    </style>
  </head>
  <body>
    <h2>Graph Coloring</h2>

    <div class="controls">
      <div class="left">
        <label>
          Кількість вершин:
          <input
            id="vertexCount"
            type="number"
            min="1"
            value="5"
            style="width: 100%"
          />
        </label>

        <label>
          Кількість кольорів:
          <input
            id="colorCount"
            type="number"
            min="1"
            value="3"
            style="width: 100%"
          />
        </label>

        <label>
          Ребра (через кому, напр.: 0-1, 0-2, 1-3):
          <textarea id="edgesInput" rows="3" cols="28">
0-1, 1-2, 2-3, 2-0, 1-4, 4-2, 4-3</textarea
          >
        </label>

        <div style="display: flex; gap: 8px">
          <button id="instantBtn">Виконати миттєво</button>
          <button id="animateBtn">Виконати анімацію</button>
        </div>
      </div>

      <div id="canvasWrap">
        <svg id="svg" width="720" height="640" viewBox="0 0 720 640"></svg>
      </div>
    </div>

    <script>
      function parseEdges(input) {
        return input
          .split(",")
          .map((e) => e.trim())
          .filter((e) => e.includes("-"))
          .map((e) => e.split("-").map((s) => Number(s.trim())));
      }

      function buildAdjList(n, edges) {
        const adj = Array.from({ length: n }, () => []);
        for (const [a, b] of edges) {
          if (
            Number.isFinite(a) &&
            Number.isFinite(b) &&
            a >= 0 &&
            b >= 0 &&
            a < n &&
            b < n
          ) {
            if (!adj[a].includes(b)) adj[a].push(b);
            if (!adj[b].includes(a)) adj[b].push(a);
          }
        }
        return adj;
      }

      const actions = [];
      function record(type, payload) {
        actions.push({ type, ...payload });
      }

      function colorGraphRecord(vertex, adjList, colors, maxColors) {
        const n = adjList.length;
        if (vertex === n) {
          record("found", { colors: [...colors] });
          return true;
        }

        for (let c = 1; c <= maxColors; c++) {
          record("try", { vertex, color: c });
          let ok = true;
          for (let neighbor of adjList[vertex]) {
            if (colors[neighbor] === c) {
              record("conflict", { vertex, color: c, neighbor });
              ok = false;
              break;
            }
          }
          if (!ok) continue;

          colors[vertex] = c;
          record("assign", { vertex, color: c });

          if (colorGraphRecord(vertex + 1, adjList, colors, maxColors))
            return true;

          colors[vertex] = 0;
          record("backtrack", { vertex });
        }

        record("no", { vertex });
        return false;
      }

      const svg = document.getElementById("svg");
      const W = 720,
        H = 640,
        CX = W / 2,
        CY = H / 2;
      let nodes = [];
      let edgeEls = [];

      function layoutNodes(n) {
        nodes = [];
        const r = Math.min(W, H) / 2 - 80;
        for (let i = 0; i < n; i++) {
          const ang = (i / n) * Math.PI * 2 - Math.PI / 2;
          const x = CX + r * Math.cos(ang);
          const y = CY + r * Math.sin(ang);
          nodes.push({ id: i, x, y });
        }
      }

      const palette = [
        "#e6194b",
        "#3cb44b",
        "#ffe119",
        "#4363d8",
        "#f58231",
        "#911eb4",
        "#46f0f0",
        "#f032e6",
        "#bcf60c",
        "#fabebe",
      ];

      function drawGraph(n, edges) {
        svg.innerHTML = "";
        layoutNodes(n);
        edgeEls = [];
        for (const [a, b] of edges) {
          const A = nodes[a],
            B = nodes[b];
          const line = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "line"
          );
          line.setAttribute("x1", A.x);
          line.setAttribute("y1", A.y);
          line.setAttribute("x2", B.x);
          line.setAttribute("y2", B.y);
          line.setAttribute("stroke", "#999");
          line.setAttribute("stroke-width", "2");
          svg.appendChild(line);
          edgeEls.push({ el: line, a, b });
        }
        for (const node of nodes) {
          const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
          g.setAttribute("transform", `translate(${node.x},${node.y})`);
          const circle = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "circle"
          );
          circle.setAttribute("r", 26);
          circle.setAttribute("fill", "#ffffff");
          circle.setAttribute("stroke", "#333");
          circle.setAttribute("stroke-width", "2");
          const text = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "text"
          );
          text.setAttribute("y", "6");
          text.setAttribute("x", "0");
          text.setAttribute("text-anchor", "middle");
          text.setAttribute("font-size", "13");
          text.textContent = node.id;
          g.appendChild(circle);
          g.appendChild(text);
          svg.appendChild(g);
          node.circleEl = circle;
          node.textEl = text;
          node.group = g;
        }
      }

      function setNodeColor(i, colorIndex) {
        const node = nodes[i];
        if (!node) return;
        if (!colorIndex || colorIndex <= 0) {
          node.circleEl.setAttribute("fill", "#fff");
        } else {
          const c = palette[(colorIndex - 1) % palette.length];
          node.circleEl.setAttribute("fill", c);
        }
      }

      function highlightNode(i) {
        nodes.forEach((n) => n.circleEl.setAttribute("stroke", "#333"));
        if (nodes[i]) nodes[i].circleEl.setAttribute("stroke", "#000");
      }

      function flashEdge(a, b) {
        const e = edgeEls.find(
          (x) => (x.a === a && x.b === b) || (x.a === b && x.b === a)
        );
        if (!e) return;
        const orig = e.el.getAttribute("stroke");
        e.el.setAttribute("stroke", "#e33");
        setTimeout(() => e.el.setAttribute("stroke", orig), 300);
      }

      let animTimer = null;
      let animIndex = 0;
      let playing = false;
      let currentColors = [];

      function resetAnimation() {
        if (animTimer) {
          clearTimeout(animTimer);
          animTimer = null;
        }
        animIndex = 0;
        playing = false;
        currentColors = [];
      }

      function animateStep() {
        if (animIndex >= actions.length) {
          playing = false;
          return;
        }
        const act = actions[animIndex++];
        switch (act.type) {
          case "try":
            highlightNode(act.vertex);
            break;
          case "conflict":
            highlightNode(act.vertex);
            flashEdge(act.vertex, act.neighbor);
            break;
          case "assign":
            currentColors[act.vertex] = act.color;
            setNodeColor(act.vertex, act.color);
            highlightNode(act.vertex);
            break;
          case "backtrack":
            currentColors[act.vertex] = 0;
            setNodeColor(act.vertex, 0);
            highlightNode(act.vertex);
            break;
          case "found":
            for (let i = 0; i < currentColors.length; i++)
              setNodeColor(i, currentColors[i] || 0);
            nodes.forEach((n) => n.circleEl.setAttribute("stroke", "#000"));
            break;
          case "no":
            highlightNode(act.vertex);
            break;
        }
        if (playing) animTimer = setTimeout(animateStep, 300);
      }

      function playAnimation() {
        if (playing) return;
        playing = true;
        animateStep();
      }
      function runInstant() {
        for (let i = 0; i < actions.length; i++) {
          const act = actions[i];
          if (act.type === "assign") currentColors[act.vertex] = act.color;
          if (act.type === "backtrack") currentColors[act.vertex] = 0;
        }
        for (let i = 0; i < currentColors.length; i++)
          setNodeColor(i, currentColors[i] || 0);
      }

      function eval() {
        const n = Number(document.getElementById("vertexCount").value);
        const edges = parseEdges(document.getElementById("edgesInput").value);
        const maxColors = Number(document.getElementById("colorCount").value);
        const adj = buildAdjList(n, edges);
        actions.length = 0;
        const colors = Array(n).fill(0);
        drawGraph(n, edges);
        resetAnimation();
        colorGraphRecord(0, adj, colors, maxColors);
        currentColors = Array(n).fill(0);
      }

      document.getElementById("animateBtn").addEventListener("click", () => {
        eval();
        playAnimation();
      });

      document.getElementById("instantBtn").addEventListener("click", () => {
        eval();
        runInstant();
      });

      (function init() {
        const n = Number(document.getElementById("vertexCount").value);
        const edges = parseEdges(document.getElementById("edgesInput").value);
        drawGraph(n, edges);
      })();
    </script>
  </body>
</html>
